#!/bin/bash
#
# Sync TLS certificates from rancher-manager cluster to downstream clusters
#
# This script copies TLS secrets generated by cert-manager on rancher-manager
# to downstream clusters (nprd-apps, poc-apps, prd-apps), reducing Let's Encrypt
# certificate requests from 8 (4 clusters √ó 2 certs) to just 2 (wildcard-net, wildcard-ai).
#
# Secrets to copy:
# - cert-manager/wildcard-dataknife-net-tls
# - cert-manager/wildcard-dataknife-ai-tls
# - kube-system/wildcard-dataknife-net-tls (for nginx default SSL)
#
# Usage:
#   ./sync-certs-from-rancher-manager.sh [target-cluster]
#   If target-cluster is not specified, syncs to all downstream clusters
#
# Prerequisites:
#   - kubectl configured with contexts: rancher-manager, nprd-apps, poc-apps, prd-apps
#   - Secrets must exist on rancher-manager cluster

set -euo pipefail

SOURCE_CLUSTER="rancher-manager"
DOWNSTREAM_CLUSTERS=("nprd-apps" "poc-apps" "prd-apps")

# Secrets to copy: namespace/secret-name
SECRETS=(
    "cert-manager/wildcard-dataknife-net-tls"
    "cert-manager/wildcard-dataknife-ai-tls"
    "kube-system/wildcard-dataknife-net-tls"
)

# Function to copy a secret from source to target cluster
copy_secret() {
    local source_ctx="$1"
    local target_ctx="$2"
    local namespace="${3%%/*}"
    local secret_name="${3##*/}"

    echo "  Copying ${namespace}/${secret_name} from ${source_ctx} to ${target_ctx}..."

    # Check if secret exists on source cluster
    if ! kubectl --context="${source_ctx}" get secret -n "${namespace}" "${secret_name}" >/dev/null 2>&1; then
        echo "    ‚ö†Ô∏è  Secret ${namespace}/${secret_name} not found on ${source_ctx}, skipping..."
        return 1
    fi

    # Get secret data from source cluster
    local secret_data
    secret_data=$(kubectl --context="${source_ctx}" get secret -n "${namespace}" "${secret_name}" -o json)

    # Extract secret type
    local secret_type
    secret_type=$(echo "${secret_data}" | jq -r '.type // "Opaque"')

    # Extract data and create new secret manifest
    local new_secret
    new_secret=$(echo "${secret_data}" | jq -c '{
        apiVersion: "v1",
        kind: "Secret",
        metadata: {
            name: .metadata.name,
            namespace: .metadata.namespace,
            labels: (.metadata.labels // {}),
            annotations: (.metadata.annotations // {})
        },
        type: .type,
        data: .data
    }')

    # Apply to target cluster
    echo "${new_secret}" | kubectl --context="${target_ctx}" apply -f -

    echo "    ‚úÖ Secret ${namespace}/${secret_name} synced successfully"
}

# Function to sync secrets to a target cluster
sync_to_cluster() {
    local target_cluster="$1"
    
    echo ""
    echo "üîÑ Syncing certificates to ${target_cluster}..."
    
    for secret in "${SECRETS[@]}"; do
        copy_secret "${SOURCE_CLUSTER}" "${target_cluster}" "${secret}" || true
    done
    
    echo "‚úÖ Finished syncing to ${target_cluster}"
}

# Main logic
TARGET_CLUSTER="${1:-}"

if [[ -n "${TARGET_CLUSTER}" ]]; then
    # Sync to specific cluster
    if [[ ! " ${DOWNSTREAM_CLUSTERS[*]} " =~ " ${TARGET_CLUSTER} " ]]; then
        echo "‚ùå Error: ${TARGET_CLUSTER} is not a downstream cluster."
        echo "   Valid downstream clusters: ${DOWNSTREAM_CLUSTERS[*]}"
        exit 1
    fi
    sync_to_cluster "${TARGET_CLUSTER}"
else
    # Sync to all downstream clusters
    echo "üìã Syncing certificates from ${SOURCE_CLUSTER} to all downstream clusters..."
    for cluster in "${DOWNSTREAM_CLUSTERS[@]}"; do
        sync_to_cluster "${cluster}"
    done
    echo ""
    echo "‚úÖ Certificate sync complete!"
fi
